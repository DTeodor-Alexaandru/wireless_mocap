#include <Arduino.h>
#include <WiFi.h>
#include "esp_camera.h"
#include "esp_http_server.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include <atomic>

// ===================== WiFi =====================
static const char* WIFI_SSID = "UPB-Guest";
static const char* WIFI_PASS = "";

// ===================== Camera pins (Adafruit OV5640 breakout -> ESP32-S3) =====================
// Assumes OV5640 breakout XCLK jumper is set to INT (internal clock), so pin_xclk = -1.
#define CAM_PIN_PWDN   15
#define CAM_PIN_RESET  -1

#define CAM_PIN_SIOD   4   // SDA
#define CAM_PIN_SIOC   5   // SCL

#define CAM_PIN_VSYNC  6   // VS
#define CAM_PIN_HREF   7   // HS
#define CAM_PIN_PCLK   13  // PC
#define CAM_PIN_XCLK   -1  // XC not used (internal clock)

#define CAM_PIN_D0     11  // D2 (Y2)
#define CAM_PIN_D1     9   // D3 (Y3)
#define CAM_PIN_D2     8   // D4 (Y4)
#define CAM_PIN_D3     10  // D5 (Y5)
#define CAM_PIN_D4     12  // D6 (Y6)
#define CAM_PIN_D5     18  // D7 (Y7)
#define CAM_PIN_D6     17  // D8 (Y8)
#define CAM_PIN_D7     16  // D9 (Y9)

// ===================== Stream / buffer =====================
static httpd_handle_t web_server = nullptr;

static SemaphoreHandle_t frame_mutex = nullptr;
static uint8_t* latest_jpeg = nullptr;
static size_t latest_len = 0;
static size_t latest_cap = 0;

static std::atomic<uint32_t> capture_count{0};

// MJPEG framing
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* STREAM_BOUNDARY     = "\r\n--frame\r\n";
static const char* STREAM_PART_HEADER  = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

// ===================== Web UI =====================
static const char INDEX_HTML[] PROGMEM = R"HTML(
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ESP32-S3 OV5640</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1.5rem; }
    img  { max-width: 100%; height: auto; border: 1px solid #ccc; }
    code { background: #f5f5f5; padding: 0.2rem 0.35rem; }
  </style>
</head>
<body>
  <h1>ESP32-S3 OV5640 (Latest Frame Stream)</h1>
  <p>MJPEG: <code>/stream</code> | Single JPEG: <code>/jpg</code></p>
  <img src="/stream" />
</body>
</html>
)HTML";

// ===================== Helpers =====================
static bool ensure_frame_capacity(size_t needed) {
  if (needed <= latest_cap) return true;

  // Grow capacity with headroom
  size_t new_cap = needed + (needed / 2) + 1024;

  // Prefer PSRAM if available
  uint8_t* new_buf = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!new_buf) {
    // Fallback to internal RAM
    new_buf = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_8BIT);
  }
  if (!new_buf) return false;

  if (latest_jpeg) {
    free(latest_jpeg);
  }
  latest_jpeg = new_buf;
  latest_cap  = new_cap;
  latest_len  = 0;
  return true;
}

// ===================== Capture task (runs as fast as possible) =====================
static void capture_task(void* pv) {
  (void)pv;

  for (;;) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      vTaskDelay(pdMS_TO_TICKS(2));
      continue;
    }

    if (fb->format == PIXFORMAT_JPEG && fb->len > 0) {
      if (xSemaphoreTake(frame_mutex, portMAX_DELAY) == pdTRUE) {
        if (ensure_frame_capacity(fb->len)) {
          memcpy(latest_jpeg, fb->buf, fb->len);
          latest_len = fb->len;
        } else {
          latest_len = 0;
        }
        xSemaphoreGive(frame_mutex);
      }
      capture_count.fetch_add(1, std::memory_order_relaxed);
    }

    esp_camera_fb_return(fb);

    // Let WiFi/HTTP tasks run, but keep capture fast.
    taskYIELD();
  }
}

// ===================== HTTP handlers =====================
static esp_err_t index_handler(httpd_req_t* req) {
  httpd_resp_set_type(req, "text/html");
  return httpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t* req) {
  if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) != pdTRUE) {
    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Mutex timeout");
    return ESP_FAIL;
  }

  if (latest_len == 0 || !latest_jpeg) {
    xSemaphoreGive(frame_mutex);
    // 503 without relying on HTTPD_503_* macros (not present in some versions)
    httpd_resp_set_status(req, "503 Service Unavailable");
    httpd_resp_set_type(req, "text/plain");
    return httpd_resp_send(req, "No frame yet", HTTPD_RESP_USE_STRLEN);
  }

  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char*)latest_jpeg, latest_len);
  xSemaphoreGive(frame_mutex);
  return res;
}

static esp_err_t stream_handler(httpd_req_t* req) {
  httpd_resp_set_type(req, STREAM_CONTENT_TYPE);
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");

  // Per-connection reusable buffer
  uint8_t* local = nullptr;
  size_t local_cap = 0;

  while (true) {
    size_t len = 0;

    if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) != pdTRUE) {
      continue;
    }

    len = latest_len;
    if (len == 0 || !latest_jpeg) {
      xSemaphoreGive(frame_mutex);
      vTaskDelay(pdMS_TO_TICKS(5));
      continue;
    }

    if (len > local_cap) {
      uint8_t* new_local = (uint8_t*)realloc(local, len);
      if (!new_local) {
        xSemaphoreGive(frame_mutex);
        free(local);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Stream realloc failed");
        return ESP_FAIL;
      }
      local = new_local;
      local_cap = len;
    }

    memcpy(local, latest_jpeg, len);
    xSemaphoreGive(frame_mutex);

    // Send boundary
    esp_err_t res = httpd_resp_send_chunk(req, STREAM_BOUNDARY, strlen(STREAM_BOUNDARY));
    if (res != ESP_OK) break;

    // Send header
    char header[128];
    int hlen = snprintf(header, sizeof(header), STREAM_PART_HEADER, (unsigned)len);
    res = httpd_resp_send_chunk(req, header, hlen);
    if (res != ESP_OK) break;

    // Send JPEG
    res = httpd_resp_send_chunk(req, (const char*)local, len);
    if (res != ESP_OK) break;

    // No explicit delay: push as fast as the client accepts
    taskYIELD();
  }

  free(local);
  httpd_resp_send_chunk(req, nullptr, 0);
  return ESP_OK;
}

static void start_webserver() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;

  if (httpd_start(&web_server, &config) == ESP_OK) {
    httpd_uri_t uri_index = { .uri = "/", .method = HTTP_GET, .handler = index_handler, .user_ctx = nullptr };
    httpd_register_uri_handler(web_server, &uri_index);

    httpd_uri_t uri_stream = { .uri = "/stream", .method = HTTP_GET, .handler = stream_handler, .user_ctx = nullptr };
    httpd_register_uri_handler(web_server, &uri_stream);

    httpd_uri_t uri_jpg = { .uri = "/jpg", .method = HTTP_GET, .handler = jpg_handler, .user_ctx = nullptr };
    httpd_register_uri_handler(web_server, &uri_jpg);
  }
}

// ===================== Setup =====================
void setup() {
  Serial.begin(115200);
  delay(500);

  frame_mutex = xSemaphoreCreateMutex();
  if (!frame_mutex) {
    Serial.println("Failed to create mutex");
    while (true) delay(1000);
  }

  // WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(250);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());

  // Camera config: fastest practical, low quality, QVGA
  camera_config_t cfg;
  cfg.ledc_channel = LEDC_CHANNEL_0;
  cfg.ledc_timer   = LEDC_TIMER_0;

  cfg.pin_d0 = CAM_PIN_D0;
  cfg.pin_d1 = CAM_PIN_D1;
  cfg.pin_d2 = CAM_PIN_D2;
  cfg.pin_d3 = CAM_PIN_D3;
  cfg.pin_d4 = CAM_PIN_D4;
  cfg.pin_d5 = CAM_PIN_D5;
  cfg.pin_d6 = CAM_PIN_D6;
  cfg.pin_d7 = CAM_PIN_D7;

  cfg.pin_xclk  = CAM_PIN_XCLK;
  cfg.pin_pclk  = CAM_PIN_PCLK;
  cfg.pin_vsync = CAM_PIN_VSYNC;
  cfg.pin_href  = CAM_PIN_HREF;

  // New (non-deprecated) names:
  cfg.pin_sccb_sda = CAM_PIN_SIOD;
  cfg.pin_sccb_scl = CAM_PIN_SIOC;

  cfg.pin_pwdn  = CAM_PIN_PWDN;
  cfg.pin_reset = CAM_PIN_RESET;

  // Not used when pin_xclk = -1, but keep a sane default
  cfg.xclk_freq_hz = 20000000;

  cfg.pixel_format = PIXFORMAT_JPEG;

  // Low quality / high compression for speed
  cfg.frame_size   = FRAMESIZE_QVGA; // 320x240
  cfg.jpeg_quality = 55;            // higher = smaller JPEG, lower quality (try 45â€“63)
  cfg.fb_count     = 2;             // helps pipeline on S3; try 1 if you want even lower latency
  cfg.grab_mode    = CAMERA_GRAB_LATEST;

  cfg.fb_location  = psramFound() ? CAMERA_FB_IN_PSRAM : CAMERA_FB_IN_DRAM;

  esp_err_t err = esp_camera_init(&cfg);
  if (err != ESP_OK) {
    Serial.printf("esp_camera_init failed: 0x%x\n", err);
    Serial.println("Check wiring and that the OV5640 clock jumper is set to INT.");
    while (true) delay(1000);
  }

  // Optional: minimize extra processing
  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_framesize(s, FRAMESIZE_QVGA);
    s->set_quality(s, 55);

    s->set_special_effect(s, 0);
    s->set_wb_mode(s, 0);
    s->set_awb_gain(s, 0);

    // Keep auto exposure/gain so frames remain visible across lighting changes.
    s->set_gain_ctrl(s, 1);
    s->set_exposure_ctrl(s, 1);
  }

  // Start capture task
  xTaskCreatePinnedToCore(
    capture_task,
    "capture_task",
    8192,
    nullptr,
    3,
    nullptr,
    1
  );

  start_webserver();
  Serial.println("Open http://<IP>/  (stream: /stream, single jpg: /jpg)");
}

// ===================== Loop: print capture FPS =====================
void loop() {
  static uint32_t last_count = 0;
  static uint32_t last_ms = 0;

  uint32_t now = millis();
  if (last_ms == 0) last_ms = now;

  if (now - last_ms >= 1000) {
    uint32_t cnt = capture_count.load(std::memory_order_relaxed);
    uint32_t fps = cnt - last_count;
    last_count = cnt;
    last_ms = now;

    Serial.print("Capture FPS (ESP32): ");
    Serial.println(fps);
  }

  delay(10);
}
