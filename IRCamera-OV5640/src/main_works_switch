#include <Arduino.h>
#include <WiFi.h>
#include "esp_camera.h"
#include "esp_http_server.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include <atomic>

#include "img_converters.h"  // jpg2rgb565(), jpg_scale_t

// ===================== MODE SELECT (GPIO1 toggle) =====================
// GPIO1 INPUT_PULLUP
//   HIGH -> WiFi + Stream enabled
//   LOW  -> Detection only (no WiFi / no web server)
static constexpr int MODE_PIN = 1;

// ===================== WiFi =====================
static const char* WIFI_SSID = "UPB-Guest";
static const char* WIFI_PASS = "";

// ===================== Camera pins (Adafruit OV5640 breakout -> ESP32-S3) =====================
// Assumes OV5640 breakout XCLK jumper is set to INT (internal clock), so pin_xclk = -1.
#define CAM_PIN_PWDN   15
#define CAM_PIN_RESET  -1

#define CAM_PIN_SIOD   4
#define CAM_PIN_SIOC   5

#define CAM_PIN_VSYNC  6
#define CAM_PIN_HREF   7
#define CAM_PIN_PCLK   13
#define CAM_PIN_XCLK   -1

#define CAM_PIN_D0     11
#define CAM_PIN_D1     9
#define CAM_PIN_D2     8
#define CAM_PIN_D3     10
#define CAM_PIN_D4     12
#define CAM_PIN_D5     18
#define CAM_PIN_D6     17
#define CAM_PIN_D7     16

// ===================== Stream / buffer =====================
static httpd_handle_t web_server = nullptr;

static SemaphoreHandle_t frame_mutex = nullptr;
static uint8_t* latest_jpeg = nullptr;
static size_t latest_len = 0;
static size_t latest_cap = 0;

static std::atomic<uint32_t> capture_count{0};

// MJPEG framing
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* STREAM_BOUNDARY     = "\r\n--frame\r\n";
static const char* STREAM_PART_HEADER  = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

// ===================== Web UI =====================
static const char INDEX_HTML[] PROGMEM = R"HTML(
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ESP32-S3 OV5640</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1.5rem; }
    img  { max-width: 100%; height: auto; border: 1px solid #ccc; }
    code { background: #f5f5f5; padding: 0.2rem 0.35rem; }
  </style>
</head>
<body>
  <h1>ESP32-S3 OV5640 (VGA Stream)</h1>
  <p>MJPEG: <code>/stream</code> | Single JPEG: <code>/jpg</code></p>
  <img src="/stream" />
</body>
</html>
)HTML";

// ===================== Helpers =====================
static bool ensure_frame_capacity(size_t needed) {
  if (needed <= latest_cap) return true;

  size_t new_cap = needed + (needed / 2) + 2048;

  uint8_t* new_buf = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!new_buf) new_buf = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_8BIT);
  if (!new_buf) return false;

  if (latest_jpeg) free(latest_jpeg);
  latest_jpeg = new_buf;
  latest_cap  = new_cap;
  latest_len  = 0;
  return true;
}

static void camera_power_cycle() {
  pinMode(CAM_PIN_PWDN, OUTPUT);
  digitalWrite(CAM_PIN_PWDN, 1);
  delay(50);
  digitalWrite(CAM_PIN_PWDN, 0);
  delay(50);
}

// ===================== Capture task =====================
static void capture_task(void* pv) {
  (void)pv;

  for (;;) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      vTaskDelay(pdMS_TO_TICKS(2));
      continue;
    }

    if (fb->format == PIXFORMAT_JPEG && fb->len > 0) {
      if (xSemaphoreTake(frame_mutex, portMAX_DELAY) == pdTRUE) {
        if (ensure_frame_capacity(fb->len)) {
          memcpy(latest_jpeg, fb->buf, fb->len);
          latest_len = fb->len;
        } else {
          latest_len = 0;
        }
        xSemaphoreGive(frame_mutex);
      }
      capture_count.fetch_add(1, std::memory_order_relaxed);
    }

    esp_camera_fb_return(fb);
    taskYIELD();
  }
}

// ===================== IR marker detection (FULL VGA, RLE-CCL) =====================
static constexpr int SRC_W = 640;
static constexpr int SRC_H = 480;

static constexpr uint8_t  LUMA_THR = 80;
static constexpr uint32_t MIN_AREA = 2;
static constexpr uint32_t MAX_AREA = 3000;

static constexpr int MAX_RUNS_PER_ROW = 400;
static constexpr int MAX_COMPONENTS   = 200;
static constexpr int MAX_PRINT        = 10;

struct Run { int x0, x1; int label; };
struct Comp {
  int parent;
  uint32_t area;
  uint32_t sumx;
  uint32_t sumy;
  bool used;
};

static uint8_t*  jpeg_copy = nullptr;
static size_t    jpeg_copy_cap = 0;

static uint16_t* rgb565_buf = nullptr;
static size_t    rgb565_cap_bytes = 0;

static bool ensure_jpeg_copy_capacity(size_t needed) {
  if (needed <= jpeg_copy_cap) return true;
  size_t new_cap = needed + (needed / 2) + 1024;

  uint8_t* nb = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!nb) nb = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_8BIT);
  if (!nb) return false;

  if (jpeg_copy) free(jpeg_copy);
  jpeg_copy = nb;
  jpeg_copy_cap = new_cap;
  return true;
}

static bool ensure_rgb565_capacity() {
  const size_t need = (size_t)SRC_W * (size_t)SRC_H * 2;
  if (rgb565_buf && need <= rgb565_cap_bytes) return true;

  uint16_t* nb = (uint16_t*)heap_caps_malloc(need, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!nb) nb = (uint16_t*)heap_caps_malloc(need, MALLOC_CAP_8BIT);
  if (!nb) return false;

  if (rgb565_buf) free(rgb565_buf);
  rgb565_buf = nb;
  rgb565_cap_bytes = need;
  return true;
}

static inline uint8_t rgb565_luma(uint16_t p) {
  uint8_t r = ((p >> 11) & 0x1F) << 3;
  uint8_t g = ((p >> 5)  & 0x3F) << 2;
  uint8_t b = ( p        & 0x1F) << 3;
  return (uint8_t)((77 * r + 150 * g + 29 * b) >> 8);
}

static int find_root(Comp* comps, int a) {
  while (comps[a].parent != a) {
    comps[a].parent = comps[comps[a].parent].parent;
    a = comps[a].parent;
  }
  return a;
}

static void unite(Comp* comps, int a, int b) {
  int ra = find_root(comps, a);
  int rb = find_root(comps, b);
  if (ra == rb) return;

  if (comps[ra].area < comps[rb].area) {
    int t = ra; ra = rb; rb = t;
  }
  comps[rb].parent = ra;
  comps[ra].area += comps[rb].area;
  comps[ra].sumx += comps[rb].sumx;
  comps[ra].sumy += comps[rb].sumy;
  comps[rb].used = false;
}

static inline uint32_t sum_range(int x0, int x1) {
  uint32_t len = (uint32_t)(x1 - x0);
  return (uint32_t)(x0 + (x1 - 1)) * len / 2;
}

static void detect_ir_full_vga_and_print(const uint16_t* img) {
  Run prev_runs[MAX_RUNS_PER_ROW];
  Run curr_runs[MAX_RUNS_PER_ROW];
  int prev_n = 0;

  Comp comps[MAX_COMPONENTS];
  int comp_n = 0;

  auto new_comp = [&]() -> int {
    if (comp_n >= MAX_COMPONENTS) return -1;
    comps[comp_n] = { comp_n, 0, 0, 0, true };
    return comp_n++;
  };

  for (int y = 0; y < SRC_H; y++) {
    int curr_n = 0;
    int x = 0;
    const uint16_t* row = img + (y * SRC_W);

    while (x < SRC_W) {
      while (x < SRC_W && rgb565_luma(row[x]) < LUMA_THR) x++;
      if (x >= SRC_W) break;

      int x0 = x;
      while (x < SRC_W && rgb565_luma(row[x]) >= LUMA_THR) x++;
      int x1 = x;

      if (curr_n >= MAX_RUNS_PER_ROW) {
        Serial.println("IR: too many runs (noise) - skipping frame");
        return;
      }

      curr_runs[curr_n++] = { x0, x1, -1 };
    }

    int pi = 0;
    for (int ci = 0; ci < curr_n; ci++) {
      Run& cr = curr_runs[ci];

      while (pi < prev_n && prev_runs[pi].x1 <= cr.x0) pi++;

      int label = -1;
      int pj = pi;
      while (pj < prev_n && prev_runs[pj].x0 < cr.x1) {
        int pl = prev_runs[pj].label;
        if (pl >= 0) {
          if (label < 0) label = pl;
          else unite(comps, label, pl);
        }
        pj++;
      }

      if (label < 0) {
        label = new_comp();
        if (label < 0) {
          Serial.println("IR: too many components - skipping frame");
          return;
        }
      }

      label = find_root(comps, label);
      cr.label = label;

      uint32_t len = (uint32_t)(cr.x1 - cr.x0);
      comps[label].area += len;
      comps[label].sumx += sum_range(cr.x0, cr.x1);
      comps[label].sumy += (uint32_t)y * len;
    }

    for (int ci = 0; ci < curr_n; ci++) {
      curr_runs[ci].label = find_root(comps, curr_runs[ci].label);
    }

    prev_n = curr_n;
    for (int i = 0; i < curr_n; i++) prev_runs[i] = curr_runs[i];
  }

  int printed = 0;
  Serial.print("IR blobs: ");
  for (int i = 0; i < comp_n && printed < MAX_PRINT; i++) {
    if (!comps[i].used) continue;
    if (comps[i].parent != i) continue;
    if (comps[i].area < MIN_AREA || comps[i].area > MAX_AREA) continue;

    int cx = (int)(comps[i].sumx / comps[i].area);
    int cy = (int)(comps[i].sumy / comps[i].area);

    Serial.printf("(%d,%d)[%u] ", cx, cy, (unsigned)comps[i].area);
    printed++;
  }
  if (printed == 0) Serial.print("none");
  Serial.println();
}

static void detect_task(void* pv) {
  (void)pv;

  if (!ensure_rgb565_capacity()) {
    Serial.println("detect_task: failed to allocate RGB565 buffer");
    vTaskDelete(nullptr);
    return;
  }

  for (;;) {
    size_t len = 0;

    if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) == pdTRUE) {
      len = latest_len;
      if (len && latest_jpeg) {
        if (ensure_jpeg_copy_capacity(len)) {
          memcpy(jpeg_copy, latest_jpeg, len);
        } else {
          len = 0;
        }
      } else {
        len = 0;
      }
      xSemaphoreGive(frame_mutex);
    }

    if (len == 0) {
      vTaskDelay(pdMS_TO_TICKS(50));
      continue;
    }

    bool ok = jpg2rgb565(jpeg_copy, len, (uint8_t*)rgb565_buf, JPG_SCALE_NONE);
    if (ok) {
      detect_ir_full_vga_and_print(rgb565_buf);
    } else {
      Serial.println("IR: decode failed");
    }

    vTaskDelay(pdMS_TO_TICKS(80));
  }
}

// ===================== HTTP handlers =====================
static esp_err_t index_handler(httpd_req_t* req) {
  httpd_resp_set_type(req, "text/html");
  return httpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t* req) {
  if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) != pdTRUE) {
    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Mutex timeout");
    return ESP_FAIL;
  }

  if (latest_len == 0 || !latest_jpeg) {
    xSemaphoreGive(frame_mutex);
    httpd_resp_set_status(req, "503 Service Unavailable");
    httpd_resp_set_type(req, "text/plain");
    return httpd_resp_send(req, "No frame yet", HTTPD_RESP_USE_STRLEN);
  }

  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char*)latest_jpeg, latest_len);
  xSemaphoreGive(frame_mutex);
  return res;
}

static esp_err_t stream_handler(httpd_req_t* req) {
  httpd_resp_set_type(req, STREAM_CONTENT_TYPE);
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");

  uint8_t* local = nullptr;
  size_t local_cap = 0;

  while (true) {
    size_t len = 0;

    if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) != pdTRUE) {
      continue;
    }

    len = latest_len;
    if (len == 0 || !latest_jpeg) {
      xSemaphoreGive(frame_mutex);
      vTaskDelay(pdMS_TO_TICKS(5));
      continue;
    }

    if (len > local_cap) {
      uint8_t* new_local = (uint8_t*)realloc(local, len);
      if (!new_local) {
        xSemaphoreGive(frame_mutex);
        free(local);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Stream realloc failed");
        return ESP_FAIL;
      }
      local = new_local;
      local_cap = len;
    }

    memcpy(local, latest_jpeg, len);
    xSemaphoreGive(frame_mutex);

    esp_err_t res = httpd_resp_send_chunk(req, STREAM_BOUNDARY, strlen(STREAM_BOUNDARY));
    if (res != ESP_OK) break;

    char header[128];
    int hlen = snprintf(header, sizeof(header), STREAM_PART_HEADER, (unsigned)len);
    res = httpd_resp_send_chunk(req, header, hlen);
    if (res != ESP_OK) break;

    res = httpd_resp_send_chunk(req, (const char*)local, len);
    if (res != ESP_OK) break;

    taskYIELD();
  }

  free(local);
  httpd_resp_send_chunk(req, nullptr, 0);
  return ESP_OK;
}

static void start_webserver() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;

  if (httpd_start(&web_server, &config) == ESP_OK) {
    httpd_uri_t uri_index  = { .uri = "/",       .method = HTTP_GET, .handler = index_handler,  .user_ctx = nullptr };
    httpd_uri_t uri_stream = { .uri = "/stream", .method = HTTP_GET, .handler = stream_handler, .user_ctx = nullptr };
    httpd_uri_t uri_jpg    = { .uri = "/jpg",    .method = HTTP_GET, .handler = jpg_handler,    .user_ctx = nullptr };

    httpd_register_uri_handler(web_server, &uri_index);
    httpd_register_uri_handler(web_server, &uri_stream);
    httpd_register_uri_handler(web_server, &uri_jpg);
  }
}

// ===================== Setup =====================
void setup() {
  Serial.begin(115200);
  delay(300);

  // Mode pin
  pinMode(MODE_PIN, INPUT_PULLUP);
  delay(10);
  bool stream_mode = (digitalRead(MODE_PIN) == HIGH);

  Serial.println();
  Serial.printf("MODE_PIN(GPIO%d)=%s => %s\n",
                MODE_PIN,
                stream_mode ? "HIGH" : "LOW",
                stream_mode ? "STREAM+DETECT" : "DETECT ONLY");

  frame_mutex = xSemaphoreCreateMutex();
  if (!frame_mutex) {
    Serial.println("Failed to create mutex");
    while (true) delay(1000);
  }

  camera_power_cycle();

  // If stream mode, connect WiFi (otherwise skip WiFi entirely)
  if (stream_mode) {
    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    Serial.print("Connecting to WiFi");
    while (WiFi.status() != WL_CONNECTED) {
      delay(250);
      Serial.print(".");
    }
    Serial.println();
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("WiFi/web server disabled (detection only).");
  }

  // Camera config: VGA JPEG
  camera_config_t cfg;
  cfg.ledc_channel = LEDC_CHANNEL_0;
  cfg.ledc_timer   = LEDC_TIMER_0;

  cfg.pin_d0 = CAM_PIN_D0;
  cfg.pin_d1 = CAM_PIN_D1;
  cfg.pin_d2 = CAM_PIN_D2;
  cfg.pin_d3 = CAM_PIN_D3;
  cfg.pin_d4 = CAM_PIN_D4;
  cfg.pin_d5 = CAM_PIN_D5;
  cfg.pin_d6 = CAM_PIN_D6;
  cfg.pin_d7 = CAM_PIN_D7;

  cfg.pin_xclk  = CAM_PIN_XCLK;
  cfg.pin_pclk  = CAM_PIN_PCLK;
  cfg.pin_vsync = CAM_PIN_VSYNC;
  cfg.pin_href  = CAM_PIN_HREF;

  cfg.pin_sccb_sda = CAM_PIN_SIOD;
  cfg.pin_sccb_scl = CAM_PIN_SIOC;

  cfg.pin_pwdn  = CAM_PIN_PWDN;
  cfg.pin_reset = CAM_PIN_RESET;

  cfg.xclk_freq_hz = 20000000; // unused when pin_xclk = -1

  cfg.pixel_format = PIXFORMAT_JPEG;
  cfg.frame_size   = FRAMESIZE_VGA;

  // For tiny markers: keep decent JPEG quality (lower number = better quality)
  cfg.jpeg_quality = 15;

  cfg.fb_count     = 2;
  cfg.grab_mode    = CAMERA_GRAB_LATEST;
  cfg.fb_location  = psramFound() ? CAMERA_FB_IN_PSRAM : CAMERA_FB_IN_DRAM;

  esp_err_t err = esp_camera_init(&cfg);
  if (err != ESP_OK) {
    Serial.printf("esp_camera_init failed: 0x%x\n", err);
    while (true) delay(1000);
  }

  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_framesize(s, FRAMESIZE_VGA);
    s->set_quality(s, 15);

    // Manual exposure/gain (IR-pass stability)
    s->set_exposure_ctrl(s, 0);
    s->set_gain_ctrl(s, 0);

    // Your current values (can cause lots of hot pixels in darkness; tune down if needed)
    s->set_aec_value(s, 1200);
    s->set_agc_gain(s, 16);

    // Optional feature calls (may be no-ops depending on your esp32-camera build)
    s->set_awb_gain(s, 0);
    s->set_wb_mode(s, 0);
    s->set_special_effect(s, 0);

    // If these are not available in your build, comment them out.
    // Some builds expose them; some don't.
    // s->set_denoise(s, 1);
    // s->set_bpc(s, 1);
    // s->set_wpc(s, 1);
  }

  // Start capture + detection tasks (always)
  xTaskCreatePinnedToCore(capture_task, "capture_task", 8192, nullptr, 3, nullptr, 1);
  xTaskCreatePinnedToCore(detect_task,  "detect_task",  16384, nullptr, 2, nullptr, 0);

  // Start web server only in stream mode
  if (stream_mode) {
    start_webserver();
    Serial.println("Web server ON. Open http://<IP>/  (stream: /stream, single jpg: /jpg)");
  } else {
    Serial.println("Web server OFF. Detection running only.");
  }
}

// ===================== Loop: print capture FPS =====================
void loop() {
  static uint32_t last_count = 0;
  static uint32_t last_ms = 0;

  uint32_t now = millis();
  if (last_ms == 0) last_ms = now;

  if (now - last_ms >= 1000) {
    uint32_t cnt = capture_count.load(std::memory_order_relaxed);
    uint32_t fps = cnt - last_count;
    last_count = cnt;
    last_ms = now;

    Serial.print("Capture FPS (ESP32): ");
    Serial.println(fps);
  }

  delay(10);
}
