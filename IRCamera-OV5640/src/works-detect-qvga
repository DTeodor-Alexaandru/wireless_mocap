#include <Arduino.h>
#include <WiFi.h>
#include "esp_camera.h"
#include "esp_http_server.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include <atomic>

// JPEG -> RGB565 decoder
#include "img_converters.h"   // provides jpg2rgb565(), jpg_scale_t, etc. :contentReference[oaicite:1]{index=1}

// ===================== WiFi =====================
static const char* WIFI_SSID = "UPB-Guest";
static const char* WIFI_PASS = "";

// ===================== Camera pins (Adafruit OV5640 breakout -> ESP32-S3) =====================
// Assumes OV5640 breakout XCLK jumper is set to INT (internal clock), so pin_xclk = -1.
#define CAM_PIN_PWDN   15
#define CAM_PIN_RESET  -1

#define CAM_PIN_SIOD   4   // SDA
#define CAM_PIN_SIOC   5   // SCL

#define CAM_PIN_VSYNC  6   // VS
#define CAM_PIN_HREF   7   // HS
#define CAM_PIN_PCLK   13  // PC
#define CAM_PIN_XCLK   -1  // XC not used (internal clock)

#define CAM_PIN_D0     11  // D2 (Y2)
#define CAM_PIN_D1     9   // D3 (Y3)
#define CAM_PIN_D2     8   // D4 (Y4)
#define CAM_PIN_D3     10  // D5 (Y5)
#define CAM_PIN_D4     12  // D6 (Y6)
#define CAM_PIN_D5     18  // D7 (Y7)
#define CAM_PIN_D6     17  // D8 (Y8)
#define CAM_PIN_D7     16  // D9 (Y9)

// ===================== Stream / buffer =====================
static httpd_handle_t web_server = nullptr;

static SemaphoreHandle_t frame_mutex = nullptr;
static uint8_t* latest_jpeg = nullptr;
static size_t latest_len = 0;
static size_t latest_cap = 0;

static std::atomic<uint32_t> capture_count{0};

// MJPEG framing
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=frame";
static const char* STREAM_BOUNDARY     = "\r\n--frame\r\n";
static const char* STREAM_PART_HEADER  = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

// ===================== Web UI =====================
static const char INDEX_HTML[] PROGMEM = R"HTML(
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ESP32-S3 OV5640</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1.5rem; }
    img  { max-width: 100%; height: auto; border: 1px solid #ccc; }
    code { background: #f5f5f5; padding: 0.2rem 0.35rem; }
  </style>
</head>
<body>
  <h1>ESP32-S3 OV5640</h1>
  <p>MJPEG: <code>/stream</code> | Single JPEG: <code>/jpg</code></p>
  <img src="/stream" />
</body>
</html>
)HTML";

// ===================== Helpers =====================
static bool ensure_frame_capacity(size_t needed) {
  if (needed <= latest_cap) return true;

  size_t new_cap = needed + (needed / 2) + 1024;

  uint8_t* new_buf = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!new_buf) new_buf = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_8BIT);
  if (!new_buf) return false;

  if (latest_jpeg) {
    free(latest_jpeg); // ok for heap_caps_malloc allocations in Arduino builds
  }
  latest_jpeg = new_buf;
  latest_cap  = new_cap;
  latest_len  = 0;
  return true;
}

// ===================== Capture task (runs as fast as possible) =====================
static void capture_task(void* pv) {
  (void)pv;

  for (;;) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      vTaskDelay(pdMS_TO_TICKS(2));
      continue;
    }

    if (fb->format == PIXFORMAT_JPEG && fb->len > 0) {
      if (xSemaphoreTake(frame_mutex, portMAX_DELAY) == pdTRUE) {
        if (ensure_frame_capacity(fb->len)) {
          memcpy(latest_jpeg, fb->buf, fb->len);
          latest_len = fb->len;
        } else {
          latest_len = 0;
        }
        xSemaphoreGive(frame_mutex);
      }
      capture_count.fetch_add(1, std::memory_order_relaxed);
    }

    esp_camera_fb_return(fb);
    taskYIELD();
  }
}

// ===================== White-dot detection =====================
//
// We decode JPEG -> RGB565 (optionally scaled), then find bright blobs and print centroids.
//
// You configured QVGA (320x240). We decode at scale 2x => 160x120 for speed.
static constexpr int   SRC_W = 320;
static constexpr int   SRC_H = 240;

// Detection decode scale:
// JPG_SCALE_2X => output dims are (SRC_W/2, SRC_H/2)
static constexpr jpg_scale_t DETECT_SCALE = JPG_SCALE_2X;
static constexpr int   SCALE_DIV = 2; // matches JPG_SCALE_2X
static constexpr int   DET_W = SRC_W / SCALE_DIV;
static constexpr int   DET_H = SRC_H / SCALE_DIV;

// Threshold: 0..255, higher = stricter white
static constexpr uint8_t LUMA_THR = 40;

// Blob clustering parameters (in DETECT scale pixels)
static constexpr int MAX_DOTS = 10;
static constexpr int CLUSTER_R2 = 6 * 6; // radius^2 for assigning pixels to existing blob

struct Dot {
  uint32_t sumx = 0;
  uint32_t sumy = 0;
  uint32_t n    = 0;
  int cx = 0;
  int cy = 0;
};

static uint8_t* jpeg_copy = nullptr;
static size_t   jpeg_copy_cap = 0;

static uint16_t* rgb565_buf = nullptr;  // DET_W * DET_H pixels
static size_t    rgb565_cap_bytes = 0;

static bool ensure_jpeg_copy_capacity(size_t needed) {
  if (needed <= jpeg_copy_cap) return true;
  size_t new_cap = needed + (needed / 2) + 512;

  uint8_t* nb = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!nb) nb = (uint8_t*)heap_caps_malloc(new_cap, MALLOC_CAP_8BIT);
  if (!nb) return false;

  if (jpeg_copy) free(jpeg_copy);
  jpeg_copy = nb;
  jpeg_copy_cap = new_cap;
  return true;
}

static bool ensure_rgb565_capacity() {
  const size_t need = (size_t)DET_W * (size_t)DET_H * 2;
  if (need <= rgb565_cap_bytes && rgb565_buf) return true;

  uint16_t* nb = (uint16_t*)heap_caps_malloc(need, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
  if (!nb) nb = (uint16_t*)heap_caps_malloc(need, MALLOC_CAP_8BIT);
  if (!nb) return false;

  if (rgb565_buf) free(rgb565_buf);
  rgb565_buf = nb;
  rgb565_cap_bytes = need;
  return true;
}

static inline void rgb565_to_rgb8(uint16_t p, uint8_t& r, uint8_t& g, uint8_t& b) {
  // RGB565 -> approx 8-bit channels
  r = ((p >> 11) & 0x1F) << 3;
  g = ((p >> 5)  & 0x3F) << 2;
  b = ( p        & 0x1F) << 3;
}

static inline uint8_t rgb565_luma(uint16_t p) {
  // Expand RGB565 to approx 8-bit channels
  uint8_t r = ((p >> 11) & 0x1F) << 3;
  uint8_t g = ((p >> 5)  & 0x3F) << 2;
  uint8_t b = ( p        & 0x1F) << 3;

  // Approx luminance: (0.299R + 0.587G + 0.114B)
  // Integer approximation: (77R + 150G + 29B) >> 8
  return (uint8_t)((77 * r + 150 * g + 29 * b) >> 8);
}


static void detect_nonblack_dots_and_print(const uint16_t* img) {
  Dot dots[MAX_DOTS];
  int dot_count = 0;

  for (int y = 0; y < DET_H; y++) {
    const uint16_t* row = img + (y * DET_W);
    for (int x = 0; x < DET_W; x++) {
      uint8_t lum = rgb565_luma(row[x]);
      if (lum < LUMA_THR) continue;   // treat as black background

      // assign to nearest dot cluster (simple online clustering)
      int best = -1;
      int best_d2 = 0x7FFFFFFF;

      for (int i = 0; i < dot_count; i++) {
        int dx = x - dots[i].cx;
        int dy = y - dots[i].cy;
        int d2 = dx*dx + dy*dy;
        if (d2 < best_d2) { best_d2 = d2; best = i; }
      }

      if (best >= 0 && best_d2 <= CLUSTER_R2) {
        dots[best].sumx += x;
        dots[best].sumy += y;
        dots[best].n++;
        dots[best].cx = (int)(dots[best].sumx / dots[best].n);
        dots[best].cy = (int)(dots[best].sumy / dots[best].n);
      } else if (dot_count < MAX_DOTS) {
        dots[dot_count].sumx = x;
        dots[dot_count].sumy = y;
        dots[dot_count].n    = 1;
        dots[dot_count].cx   = x;
        dots[dot_count].cy   = y;
        dot_count++;
      }
    }
  }

  // Print (scaled back to QVGA coords). Filter tiny blobs to remove noise.
  bool printed = false;
  Serial.print("dots: ");
  for (int i = 0; i < dot_count; i++) {
    if (dots[i].n < 10) continue; // tune: lower if dots are very small
    int x_qvga = dots[i].cx * SCALE_DIV;
    int y_qvga = dots[i].cy * SCALE_DIV;
    Serial.printf("(%d,%d) ", x_qvga, y_qvga);
    printed = true;
  }
  if (!printed) Serial.print("none");
  Serial.println();
}


static void detect_task(void* pv) {
  (void)pv;

  if (!ensure_rgb565_capacity()) {
    Serial.println("detect_task: failed to allocate RGB565 buffer");
    vTaskDelete(nullptr);
    return;
  }

  for (;;) {
    // Copy latest JPEG under mutex
    size_t len = 0;
    if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) == pdTRUE) {
      len = latest_len;
      if (len && latest_jpeg) {
        if (ensure_jpeg_copy_capacity(len)) {
          memcpy(jpeg_copy, latest_jpeg, len);
        } else {
          len = 0;
        }
      } else {
        len = 0;
      }
      xSemaphoreGive(frame_mutex);
    }

    if (len == 0) {
      vTaskDelay(pdMS_TO_TICKS(50));
      continue;
    }

    // Decode JPEG -> RGB565 (downscaled)
    // Signature: bool jpg2rgb565(const uint8_t *src, size_t src_len, uint8_t * out, jpg_scale_t scale); :contentReference[oaicite:2]{index=2}
    bool ok = jpg2rgb565(jpeg_copy, len, (uint8_t*)rgb565_buf, DETECT_SCALE);
    if (ok) {
      detect_nonblack_dots_and_print(rgb565_buf);
    } else {
      Serial.println("dots: decode failed");
    }

    // Run detection at a controlled rate (avoid starving capture/WiFi)
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

// ===================== HTTP handlers =====================
static esp_err_t index_handler(httpd_req_t* req) {
  httpd_resp_set_type(req, "text/html");
  return httpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);
}

static esp_err_t jpg_handler(httpd_req_t* req) {
  if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) != pdTRUE) {
    httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Mutex timeout");
    return ESP_FAIL;
  }

  if (latest_len == 0 || !latest_jpeg) {
    xSemaphoreGive(frame_mutex);
    httpd_resp_set_status(req, "503 Service Unavailable");
    httpd_resp_set_type(req, "text/plain");
    return httpd_resp_send(req, "No frame yet", HTTPD_RESP_USE_STRLEN);
  }

  httpd_resp_set_type(req, "image/jpeg");
  esp_err_t res = httpd_resp_send(req, (const char*)latest_jpeg, latest_len);
  xSemaphoreGive(frame_mutex);
  return res;
}

static esp_err_t stream_handler(httpd_req_t* req) {
  httpd_resp_set_type(req, STREAM_CONTENT_TYPE);
  httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");

  uint8_t* local = nullptr;
  size_t local_cap = 0;

  while (true) {
    size_t len = 0;

    if (xSemaphoreTake(frame_mutex, pdMS_TO_TICKS(200)) != pdTRUE) {
      continue;
    }

    len = latest_len;
    if (len == 0 || !latest_jpeg) {
      xSemaphoreGive(frame_mutex);
      vTaskDelay(pdMS_TO_TICKS(5));
      continue;
    }

    if (len > local_cap) {
      uint8_t* new_local = (uint8_t*)realloc(local, len);
      if (!new_local) {
        xSemaphoreGive(frame_mutex);
        free(local);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Stream realloc failed");
        return ESP_FAIL;
      }
      local = new_local;
      local_cap = len;
    }

    memcpy(local, latest_jpeg, len);
    xSemaphoreGive(frame_mutex);

    esp_err_t res = httpd_resp_send_chunk(req, STREAM_BOUNDARY, strlen(STREAM_BOUNDARY));
    if (res != ESP_OK) break;

    char header[128];
    int hlen = snprintf(header, sizeof(header), STREAM_PART_HEADER, (unsigned)len);
    res = httpd_resp_send_chunk(req, header, hlen);
    if (res != ESP_OK) break;

    res = httpd_resp_send_chunk(req, (const char*)local, len);
    if (res != ESP_OK) break;

    taskYIELD();
  }

  free(local);
  httpd_resp_send_chunk(req, nullptr, 0);
  return ESP_OK;
}

static void start_webserver() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();
  config.server_port = 80;

  if (httpd_start(&web_server, &config) == ESP_OK) {
    httpd_uri_t uri_index  = { .uri = "/",       .method = HTTP_GET, .handler = index_handler,  .user_ctx = nullptr };
    httpd_uri_t uri_stream = { .uri = "/stream", .method = HTTP_GET, .handler = stream_handler, .user_ctx = nullptr };
    httpd_uri_t uri_jpg    = { .uri = "/jpg",    .method = HTTP_GET, .handler = jpg_handler,    .user_ctx = nullptr };

    httpd_register_uri_handler(web_server, &uri_index);
    httpd_register_uri_handler(web_server, &uri_stream);
    httpd_register_uri_handler(web_server, &uri_jpg);
  }
}

// ===================== Setup =====================
void setup() {
  Serial.begin(115200);
  delay(500);

  frame_mutex = xSemaphoreCreateMutex();
  if (!frame_mutex) {
    Serial.println("Failed to create mutex");
    while (true) delay(1000);
  }

  // WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(250);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());

  // Camera config: QVGA JPEG
  camera_config_t cfg;
  cfg.ledc_channel = LEDC_CHANNEL_0;
  cfg.ledc_timer   = LEDC_TIMER_0;

  cfg.pin_d0 = CAM_PIN_D0;
  cfg.pin_d1 = CAM_PIN_D1;
  cfg.pin_d2 = CAM_PIN_D2;
  cfg.pin_d3 = CAM_PIN_D3;
  cfg.pin_d4 = CAM_PIN_D4;
  cfg.pin_d5 = CAM_PIN_D5;
  cfg.pin_d6 = CAM_PIN_D6;
  cfg.pin_d7 = CAM_PIN_D7;

  cfg.pin_xclk  = CAM_PIN_XCLK;
  cfg.pin_pclk  = CAM_PIN_PCLK;
  cfg.pin_vsync = CAM_PIN_VSYNC;
  cfg.pin_href  = CAM_PIN_HREF;

  cfg.pin_sccb_sda = CAM_PIN_SIOD;
  cfg.pin_sccb_scl = CAM_PIN_SIOC;

  cfg.pin_pwdn  = CAM_PIN_PWDN;
  cfg.pin_reset = CAM_PIN_RESET;

  cfg.xclk_freq_hz = 20000000; // unused when pin_xclk = -1

  cfg.pixel_format = PIXFORMAT_JPEG;

  cfg.frame_size   = FRAMESIZE_QVGA; // 320x240

  // Highest compression (lowest quality): 63 is max compression
  cfg.jpeg_quality = 63;

  cfg.fb_count     = 2;
  cfg.grab_mode    = CAMERA_GRAB_LATEST;
  cfg.fb_location  = psramFound() ? CAMERA_FB_IN_PSRAM : CAMERA_FB_IN_DRAM;

  esp_err_t err = esp_camera_init(&cfg);
  if (err != ESP_OK) {
    Serial.printf("esp_camera_init failed: 0x%x\n", err);
    Serial.println("Check wiring and that the OV5640 clock jumper is set to INT.");
    while (true) delay(1000);
  }

  // Optional: minimize extra processing
  sensor_t* s = esp_camera_sensor_get();
  if (s) {
    s->set_framesize(s, FRAMESIZE_QVGA);
    s->set_quality(s, 63);
  }

  // Start capture task (core 1)
  xTaskCreatePinnedToCore(
    capture_task,
    "capture_task",
    8192,
    nullptr,
    3,
    nullptr,
    1
  );

  // Start detection task (core 0)
  xTaskCreatePinnedToCore(
    detect_task,
    "detect_task",
    12288,
    nullptr,
    2,
    nullptr,
    0
  );

  start_webserver();
  Serial.println("Open http://<IP>/  (stream: /stream, single jpg: /jpg)");
}

// ===================== Loop: print capture FPS =====================
void loop() {
  static uint32_t last_count = 0;
  static uint32_t last_ms = 0;

  uint32_t now = millis();
  if (last_ms == 0) last_ms = now;

  if (now - last_ms >= 1000) {
    uint32_t cnt = capture_count.load(std::memory_order_relaxed);
    uint32_t fps = cnt - last_count;
    last_count = cnt;
    last_ms = now;

    Serial.print("Capture FPS (ESP32): ");
    Serial.println(fps);
  }

  delay(10);
}
